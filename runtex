#!/usr/bin/env python

import fcntl
import signal
import os
import code
import time
import sys
import getopt
import md5
import subprocess

class LockError(Exception):
    def __init__(self, locked_by_pid, *args, **kwargs):
        Exception.__init__(self, *args, **kwargs)
        self.locked_by_pid = locked_by_pid
class LockNonBlockError(LockError): pass
class LockTimeoutError(LockError): pass
class ExecuteTimeoutError(Exception): pass

class Runtex:
    instance = None

    @classmethod
    def init(self):
        signal.signal(signal.SIGALRM, self.on_alarm)

    @classmethod
    def on_alarm(self, *args):
        if self.instance and not self.instance.locked:
            self.instance.lock_timeout_error()
        elif self.instance and self.instance.executing:
            self.instance.execute_timeout_error()

    @classmethod
    def log(self, msg, stream=sys.stdout):
        print >> stream, "runtex: {0}".format(msg)

    def __init__(self, lock_path, lock_timeout=None, execute_timeout=None):
        self.lock_path = lock_path
        self.fd = None
        self.lock_timeout = lock_timeout
        self.execute_timeout = execute_timeout
        self.locked = False
        self.executing = False

    def __enter__(self):
        self.__class__.instance = self

        lock_dir_path = os.path.dirname(self.lock_path)
        if lock_dir_path and not os.path.exists(lock_dir_path): os.makedirs(lock_dir_path)
        self.fd = os.open(self.lock_path, os.O_CREAT|os.O_WRONLY)

        self.locked = False
        flock_flags = fcntl.LOCK_EX
        if self.lock_timeout:
            signal.alarm(self.lock_timeout)
        else:
            flock_flags |= fcntl.LOCK_NB
        try:
            fcntl.flock(self.fd, flock_flags)
        except IOError:
            self.lock_non_block_error()
        finally:
            if self.lock_timeout: signal.alarm(0)
        self.locked = True
        self.log("locked {0}".format(self.lock_path))

        os.ftruncate(self.fd, 0)
        os.write(self.fd, "{0}\n".format(os.getpid()))
        os.fsync(self.fd)

        self.executing = True
        if self.execute_timeout: signal.alarm(self.execute_timeout)

        return self

    def __exit__(self, *args):
        if self.execute_timeout: signal.alarm(0)
        self.executing = False
        self.__class__.instance = None

        fcntl.flock(self.fd, fcntl.LOCK_UN)
        os.close(self.fd)
        self.fd = None
        self.locked = False
        self.log("unlocked {0}".format(self.lock_path))

    def locked_pid(self):
        return int(open(self.lock_path, 'r').read().strip())

    def lock_non_block_error(self):
        raise LockNonBlockError(self.locked_pid())

    def lock_timeout_error(self):
        raise LockTimeoutError(self.locked_pid())

    def execute_timeout_error(self):
        raise ExecuteTimeoutError

class Cli:
    lockfile_path = "/tmp/runtex"

    def usage(self):
        print("""\
Usage: runtex2 [-w SEC] [-t SEC] [/path/to/lockfile.pid] command [args]
 Runs command with a file /path/to/lockfile.pid locked. If no lockfile.pid
 is given, it will be automatically generated in {0}.

Flags:
 -h: print this message
 -w SEC: fail only after trying to acquire a lock for SEC seconds (disabled by default)
 -t SEC: kill app after SEC seconds timeout (disabled by default)
        """.strip().format(self.lockfile_path))

    def try_pstree(self, pid):
        try:
            subprocess.call(['pstree', str(pid)])
        except OSError:
            pass

    def run(self):
        m = md5.new() ; m.update(' '.join(sys.argv))
        args_digest = m.hexdigest()

        lock_timeout = None
        execute_timeout = None
        lock_path = None
        command = None

        def complain_and_exit(message=None):
            if message: Runtex.log("{0}\n".format(message), stream=sys.stderr)
            self.usage()
            exit(1)

        try:
            opts, non_opts = getopt.getopt(sys.argv[1:], 'ht:w:')
        except getopt.GetoptError, err:
            complain_and_exit(err)

        for opt, arg in opts:
            if opt in ('-h',):
                self.usage()
                exit(0)
            elif opt in ('-w',):
                try:
                    lock_timeout = int(arg)
                except ValueError, err:
                    complain_and_exit("wait before fail value (-w) "
                                      "can be numeric only, given '{0}'".format(arg))
                if lock_timeout <= 0: lock_timeout = None
            elif opt in ('-t',):
                try:
                    execute_timeout = int(arg)
                except ValueError, err:
                    complain_and_exit("timeout value (-t) "
                                      "can be numeric only, given '{0}'".format(arg))
                if execute_timeout <= 0: execute_timeout = None

        if non_opts:
            check_filename = os.path.split(non_opts[0])[-1]
            if check_filename.endswith('.pid') and check_filename != '.pid':
                lock_path = non_opts.pop(0)
        command = non_opts

        if not lock_path:
            lock_path = os.path.join(self.lockfile_path, "{0}.pid".format(args_digest))

        Runtex.init()
        try:
            with Runtex(lock_path, lock_timeout=lock_timeout, execute_timeout=execute_timeout):
                if command:
                    cmd = subprocess.Popen(command)
                    try:
                        cmd.wait()
                    except Exception:
                        i = 1
                        while not cmd.poll():
                            if i > 10:
                                Runtex.log("trying to kill command", stream=sys.stderr)
                                cmd.kill()
                                break
                            else:
                                Runtex.log("trying to terminate command for the {0} time".format(i), stream=sys.stderr)
                                cmd.terminate()
                            time.sleep(0.5)
                            i += 1
                        raise
        except LockNonBlockError, err:
            Runtex.log("already locked by pid '{0}'".format(err.locked_by_pid), stream=sys.stderr)
            self.try_pstree(err.locked_by_pid)
            exit(1)
        except LockTimeoutError, err:
            Runtex.log("lock timeout, locked by pid '{0}'".format(err.locked_by_pid), stream=sys.stderr)
            self.try_pstree(err.locked_by_pid)
            exit(1)
        except ExecuteTimeoutError:
            Runtex.log("execute timeout", stream=sys.stderr)
            exit(124)

Cli().run()
